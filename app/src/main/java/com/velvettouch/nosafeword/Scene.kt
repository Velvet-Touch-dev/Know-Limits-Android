package com.velvettouch.nosafeword

/**
 * Data model for representing a scene from the JSON file
 */
import com.google.firebase.firestore.DocumentId
import com.google.firebase.firestore.PropertyName

data class Scene(
    @DocumentId var firestoreId: String = "", // Firestore document ID
    val id: Int = 0, // Original ID, if applicable
    val title: String = "",
    val content: String = "",
    @get:PropertyName("isCustom") // Ensures correct mapping for Firestore
    val isCustom: Boolean = false,
    var userId: String = "", // User ID for Firestore security rules
    val tags: List<String> = emptyList() // Added tags field
) {
    // Default constructor is implicitly generated by Kotlin
    // if all properties have default values.
}

// Extension function to get a persistent identifier, useful for local management and export/import.
// Mirrors the logic from ScenesViewModel's private getPersistentIdentifierForLocalScene.
fun Scene.getPersistentExportId(): String {
    // Prioritize Firestore ID if it's a real one (not local placeholder)
    if (this.firestoreId.isNotBlank() && !this.firestoreId.startsWith("local_")) {
        return this.firestoreId
    }
    // If it has a local_ prefix, use that as it's unique for that local session's item
    if (this.firestoreId.startsWith("local_")) {
        return this.firestoreId
    }
    // If it's an asset scene (not custom, has an original 'id', and no Firestore/local ID yet)
    // These are typically loaded from assets/scenes.json and have isCustom = false.
    if (!this.isCustom && this.id != 0) {
        return "asset_${this.id}" // Changed from "default_" to "asset_" to match import format
    }
    // Fallback for a new custom scene not yet saved (should ideally get a local_ ID quickly)
    // Or if somehow an item has no identifiable ID.
    // This fallback should be rare in practice if IDs are managed well.
    return "transient_${this.title.hashCode()}_${this.content.hashCode()}"
}
