package com.velvettouch.nosafeword

import android.content.Context
import android.net.Uri
import android.util.Base64
import android.util.Log
import com.google.firebase.auth.FirebaseAuth
import com.google.gson.Gson
import com.google.gson.JsonSyntaxException
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.File
import java.io.FileOutputStream
import java.util.UUID

class DataImporter(
    private val context: Context,
    private val scenesViewModel: ScenesViewModel,
    private val positionsRepository: PositionsRepository,
    private val localFavoritesRepository: LocalFavoritesRepository,
    private val cloudFavoritesRepository: FavoritesRepository, // Added
    private val firebaseAuth: FirebaseAuth
    // Consider adding ViewModels if they have complex logic not in repos
) {
    private val gson = Gson()
    private companion object {
        const val TAG = "DataImporter"
        const val TEMP_IMPORT_IMAGE_DIR = "import_temp_images"
    }

    suspend fun importDataFromJson(jsonString: String): Boolean {
        return withContext(Dispatchers.IO) {
            try {
                val importData = gson.fromJson(jsonString, AppExportData::class.java)
                val currentUser = firebaseAuth.currentUser

                // Create a temporary directory for images
                val tempImageDir = File(context.cacheDir, TEMP_IMPORT_IMAGE_DIR)
                if (!tempImageDir.exists()) tempImageDir.mkdirs()

                // 1. Import Custom Scenes
                importCustomScenes(importData.customScenes, currentUser?.uid)

                // 2. Import Custom Positions
                importCustomPositions(importData.customPositions, currentUser?.uid, tempImageDir)

                // 3. Import Favorite Scene IDs - Pass the original exported scenes for mapping
                importFavoriteSceneIds(importData.favoriteSceneExportIds, importData.customScenes, currentUser?.uid)

                // 4. Import Favorite Asset Position IDs
                importFavoriteAssetPositionIds(importData.favoriteAssetPositionExportIds, currentUser?.uid)

                // Clean up temporary image directory
                tempImageDir.deleteRecursively()
                Log.i(TAG, "Import successful.")
                true
            } catch (e: JsonSyntaxException) {
                Log.e(TAG, "Error parsing import JSON", e)
                false
            } catch (e: Exception) {
                Log.e(TAG, "Error during data import", e)
                false
            }
        }
    }

    private suspend fun importCustomScenes(scenesToImport: List<ExportableScene>, userId: String?) {
        if (scenesToImport.isEmpty()) return
        Log.d(TAG, "Importing ${scenesToImport.size} custom scenes...")

        // Fetch existing scenes to help with de-duplication.
        val existingScenes = scenesViewModel.getCurrentScenesForExport()
        val existingCustomSceneTitles = existingScenes
            .filter { it.isCustom }
            .map { it.title.lowercase() }
            .toSet()

        for (exportableScene in scenesToImport) {
            if (existingCustomSceneTitles.contains(exportableScene.title.lowercase())) {
                Log.d(TAG, "Skipping import of scene '${exportableScene.title}' as a custom scene with this title already exists.")
                continue
            }

            val newScene = Scene(
                title = exportableScene.title,
                content = exportableScene.content,
                isCustom = true, // All imported scenes are treated as custom
                userId = userId ?: "", // userId will be handled by addScene in ViewModel based on auth state
                firestoreId = "" // Will be generated by ViewModel/Repository
            )
            // Use ScenesViewModel's addScene, which handles logged-in/out state and SharedPreferences/Firestore saving.
            scenesViewModel.addScene(newScene)
            Log.d(TAG, "Called scenesViewModel.addScene for: ${newScene.title}")
        }
    }

    private suspend fun importCustomPositions(positionsToImport: List<ExportablePosition>, userId: String?, tempImageDir: File) {
        if (positionsToImport.isEmpty()) return
        Log.d(TAG, "Importing ${positionsToImport.size} custom positions...")

        for (exportablePosition in positionsToImport) {
            var tempImageFileUri: Uri? = null // URI of the decoded image file
            var localTempFileCreatedFromImageData: File? = null // Keep track of the file for manual deletion

            try {
                if (exportablePosition.imageData.isNotBlank()) {
                    val imageBytes = Base64.decode(exportablePosition.imageData, Base64.NO_WRAP)
                    // Use a unique name for the temp file to avoid conflicts if multiple imports happen quickly
                    val tempFileName = "${UUID.randomUUID()}.${getExtensionFromMimeType(exportablePosition.imageMimeType)}"
                    val tempFile = File(tempImageDir, tempFileName)
                    FileOutputStream(tempFile).use { it.write(imageBytes) }
                    tempImageFileUri = Uri.fromFile(tempFile)
                    localTempFileCreatedFromImageData = tempFile
                    Log.d(TAG, "Decoded image for ${exportablePosition.name} to temp file: ${tempFile.absolutePath}")
                }

                if (userId != null) { // Logged-in user
                    if (tempImageFileUri != null) {
                        // Logged in, and there's a new image to upload. Use the Cloud Function path.
                        Log.d(TAG, "Importing position '${exportablePosition.name}' for user $userId with new image. Using metadata upload path.")
                        val uploadSuccess = positionsRepository.uploadPositionImageWithMetadata(
                            imageUriToUpload = tempImageFileUri, // This will be copied internally by the method
                            positionName = exportablePosition.name,
                            isFavorite = exportablePosition.isFavorite,
                            forUserId = userId
                        )
                        if (uploadSuccess) {
                            Log.i(TAG, "Successfully initiated image upload with metadata for '${exportablePosition.name}'. Cloud Function will handle Firestore entry.")
                        } else {
                            Log.e(TAG, "Failed to upload image with metadata for '${exportablePosition.name}'. Position might not be created/updated by Cloud Function.")
                        }
                        // The temp file created from imageData should be deleted as uploadPositionImageWithMetadata makes its own copy if needed.
                        localTempFileCreatedFromImageData?.delete()
                        Log.d(TAG, "Deleted temp image file after metadata upload attempt: ${localTempFileCreatedFromImageData?.name}")
                    } else {
                        // Logged in, but no new image data.
                        // This could be an update to an existing position's metadata or creating a new one without an image.
                        Log.d(TAG, "Importing position '${exportablePosition.name}' for user $userId without a new image. Using addOrUpdatePosition.")
                        val positionItem = PositionItem(
                            name = exportablePosition.name,
                            isFavorite = exportablePosition.isFavorite,
                            isAsset = false,
                            imageName = "", // Let addOrUpdatePosition handle existing imageName if found, or keep blank if new & no image
                            userId = userId
                        )
                        positionsRepository.addOrUpdatePosition(positionItem, null) // null for imageUriToUpload
                    }
                } else { // Logged out user
                    Log.d(TAG, "Importing position '${exportablePosition.name}' for logged-out user.")
                    val newPositionItem = PositionItem(
                        name = exportablePosition.name,
                        isFavorite = exportablePosition.isFavorite,
                        isAsset = false,
                        imageName = "", // Will be set by addOrUpdatePosition from tempImageFileUri (local path)
                        userId = null // Explicitly null for local items
                    )
                    positionsRepository.addOrUpdatePosition(newPositionItem, tempImageFileUri)
                    // For logged-out users, addOrUpdatePosition copies the image to internal storage.
                    // The original temp file from imageData should be deleted.
                    localTempFileCreatedFromImageData?.delete()
                    Log.d(TAG, "Deleted temp image file after local import: ${localTempFileCreatedFromImageData?.name}")
                }

            } catch (e: Exception) {
                Log.e(TAG, "Failed to import position ${exportablePosition.name}", e)
                localTempFileCreatedFromImageData?.delete() // Clean up on error
                Log.d(TAG, "Deleted temp image file due to exception: ${localTempFileCreatedFromImageData?.name}")
            } finally {
                // localTempFileCreatedFromImageData is handled in try/catch.
                // The main tempImageDir is deleted at the end of importDataFromJson.
            }
        }
    }

    private fun getExtensionFromMimeType(mimeType: String): String {
        return when (mimeType.lowercase()) {
            "image/jpeg" -> "jpg"
            "image/png" -> "png"
            "image/gif" -> "gif"
            "image/webp" -> "webp"
            else -> "dat" // Default extension
        }
    }

    private suspend fun importFavoriteSceneIds(
        favoriteExportIds: List<String>,
        exportedCustomScenes: List<ExportableScene>, // Original list of custom scenes from the import file
        userId: String?
    ) {
        if (favoriteExportIds.isEmpty()) return
        Log.d(TAG, "Importing ${favoriteExportIds.size} favorite scene IDs...")

        val currentScenesInApp = scenesViewModel.getCurrentScenesForExport()

        for (favExportId in favoriteExportIds) {
            var actualSceneIdToFavorite: String? = null

            // Strategy 1: Direct match (if favExportId is a stable ID like Firestore's or default_X)
            val directMatchScene = currentScenesInApp.find { it.getPersistentExportId() == favExportId }
            if (directMatchScene != null) {
                actualSceneIdToFavorite = directMatchScene.getPersistentExportId() // Use its current persistent ID
            } else {
                // Strategy 2: If favExportId was a local_ ID or for a custom scene,
                // find its original details from the export file, then match by content in current app scenes.
                val originalExportedScene = exportedCustomScenes.find { it.exportId == favExportId }
                if (originalExportedScene != null) {
                    val contentMatchScene = currentScenesInApp.find {
                        it.isCustom && // Ensure we are matching against a custom scene
                        it.title == originalExportedScene.title &&
                        it.content == originalExportedScene.content
                    }
                    if (contentMatchScene != null) {
                        actualSceneIdToFavorite = contentMatchScene.getPersistentExportId()
                    } else {
                        Log.w(TAG, "Could not find a matching scene in app for favorite with original exportId '$favExportId' (Title: ${originalExportedScene.title}) by content.")
                    }
                } else {
                     Log.w(TAG, "Favorite scene exportId '$favExportId' not found in the exported custom scenes list. It might be a default/asset scene or an orphaned ID.")
                     // If it's a default scene ID (e.g., "default_123"), it should have been caught by directMatchScene if the default scene exists.
                     // If it's an orphaned ID, we can't do much.
                }
            }

            if (actualSceneIdToFavorite != null) {
                if (userId == null) { // Logged out
                    localFavoritesRepository.addLocalFavoriteScene(actualSceneIdToFavorite)
                    Log.d(TAG, "Marked local scene '$actualSceneIdToFavorite' as favorite.")
                } else { // Logged in
                    val result = cloudFavoritesRepository.addFavorite(actualSceneIdToFavorite, "scene")
                    if (result.isSuccess) {
                        Log.d(TAG, "Successfully marked cloud scene '$actualSceneIdToFavorite' as favorite for user $userId.")
                    } else {
                        Log.e(TAG, "Failed to mark cloud scene '$actualSceneIdToFavorite' as favorite for user $userId.", result.exceptionOrNull())
                    }
                }
            } else {
                Log.w(TAG, "Could not resolve favorite scene with exportId '$favExportId' to an existing scene in the app.")
            }
        }
    }

    private suspend fun importFavoriteAssetPositionIds(assetPositionExportIds: List<String>, userId: String?) {
        if (assetPositionExportIds.isEmpty()) return
        Log.d(TAG, "Importing ${assetPositionExportIds.size} favorite asset position IDs...")
        for (exportId in assetPositionExportIds) { // These are like "asset_ImageName.jpg"
            if (userId == null) { // Logged out
                localFavoritesRepository.addLocalFavoritePosition(exportId)
            } else { // Logged in
                // Mark asset as favorite for user in Firestore.
                val result = cloudFavoritesRepository.addFavorite(exportId, "position")
                if (result.isSuccess) {
                    Log.d(TAG, "Successfully marked cloud asset position '$exportId' as favorite for user $userId.")
                } else {
                    Log.e(TAG, "Failed to mark cloud asset position '$exportId' as favorite for user $userId.", result.exceptionOrNull())
                }
                // Note: positionsRepository.updateFavoriteStatus(exportId, true) might also be needed if
                // the PositionItem itself (if one exists for assets for users) needs its 'isFavorite' flag updated in Firestore.
                // For now, relying on the 'favorites' collection via FavoritesRepository.
            }
        }
    }
}
