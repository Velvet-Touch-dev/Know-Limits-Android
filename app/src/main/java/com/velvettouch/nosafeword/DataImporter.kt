package com.velvettouch.nosafeword

import android.content.Context
import android.net.Uri
import android.util.Base64
import android.util.Log
import com.google.firebase.auth.FirebaseAuth
import com.google.gson.Gson
import com.google.gson.JsonSyntaxException
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.File
import java.io.FileOutputStream
import java.util.UUID

class DataImporter(
    private val context: Context,
    private val scenesViewModel: ScenesViewModel,
    private val positionsRepository: PositionsRepository,
    private val localFavoritesRepository: LocalFavoritesRepository,
    private val cloudFavoritesRepository: FavoritesRepository, // Added
    private val firebaseAuth: FirebaseAuth
    // Consider adding ViewModels if they have complex logic not in repos
) {
    private val gson = Gson()
    private companion object {
        const val TAG = "DataImporter"
        const val TEMP_IMPORT_IMAGE_DIR = "import_temp_images"
    }

    suspend fun importDataFromJson(jsonString: String): Boolean {
        return withContext(Dispatchers.IO) {
            try {
                val importData = gson.fromJson(jsonString, AppExportData::class.java)
                val currentUser = firebaseAuth.currentUser

                // Create a temporary directory for images
                val tempImageDir = File(context.cacheDir, TEMP_IMPORT_IMAGE_DIR)
                if (!tempImageDir.exists()) tempImageDir.mkdirs()

                // 1. Import Custom Scenes
                importCustomScenes(importData.customScenes, currentUser?.uid)

                // 2. Import Custom Positions
                importCustomPositions(importData.customPositions, currentUser?.uid, tempImageDir)

                // 3. Import Favorite Scene IDs - Pass the original exported scenes for mapping
                importFavoriteSceneIds(importData.favoriteSceneExportIds, importData.customScenes, currentUser?.uid)

                // 4. Import Favorite Asset Position IDs
                importFavoriteAssetPositionIds(importData.favoriteAssetPositionExportIds, currentUser?.uid)

                // Clean up temporary image directory
                tempImageDir.deleteRecursively()
                Log.i(TAG, "Import successful.")
                true
            } catch (e: JsonSyntaxException) {
                Log.e(TAG, "Error parsing import JSON", e)
                false
            } catch (e: Exception) {
                Log.e(TAG, "Error during data import", e)
                false
            }
        }
    }

    private suspend fun importCustomScenes(scenesToImport: List<ExportableScene>, userId: String?) {
        if (scenesToImport.isEmpty()) return
        Log.d(TAG, "Importing ${scenesToImport.size} custom scenes...")

        // Fetch existing scenes to help with de-duplication.
        val existingScenes = scenesViewModel.getCurrentScenesForExport()
        val existingCustomSceneTitles = existingScenes
            .filter { it.isCustom }
            .map { it.title.lowercase() }
            .toSet()

        for (exportableScene in scenesToImport) {
            if (existingCustomSceneTitles.contains(exportableScene.title.lowercase())) {
                Log.d(TAG, "Skipping import of scene '${exportableScene.title}' as a custom scene with this title already exists.")
                continue
            }

            val newScene = Scene(
                title = exportableScene.title,
                content = exportableScene.content,
                isCustom = true, // All imported scenes are treated as custom
                userId = userId ?: "", // userId will be handled by addScene in ViewModel based on auth state
                firestoreId = "" // Will be generated by ViewModel/Repository
            )
            // Use ScenesViewModel's addScene, which handles logged-in/out state and SharedPreferences/Firestore saving.
            scenesViewModel.addScene(newScene)
            Log.d(TAG, "Called scenesViewModel.addScene for: ${newScene.title}")
        }
    }

    private suspend fun importCustomPositions(positionsToImport: List<ExportablePosition>, userId: String?, tempImageDir: File) {
        if (positionsToImport.isEmpty()) return
        Log.d(TAG, "Importing ${positionsToImport.size} custom positions...")

        for (exportablePosition in positionsToImport) {
            var tempImageFileUri: Uri? = null
            try {
                if (exportablePosition.imageData.isNotBlank()) {
                    val imageBytes = Base64.decode(exportablePosition.imageData, Base64.NO_WRAP)
                    val tempFile = File(tempImageDir, "${UUID.randomUUID()}.${getExtensionFromMimeType(exportablePosition.imageMimeType)}")
                    FileOutputStream(tempFile).use { it.write(imageBytes) }
                    tempImageFileUri = Uri.fromFile(tempFile)
                }

                val newPositionItem = PositionItem(
                    // id will be handled by addOrUpdatePosition (checks by name if new, or uses existing)
                    name = exportablePosition.name,
                    isFavorite = exportablePosition.isFavorite,
                    isAsset = false, // Imported positions are custom
                    imageName = "", // Will be set by addOrUpdatePosition from the tempImageFileUri
                    userId = userId // Null if logged out, set if logged in
                )
                // The addOrUpdatePosition in PositionsRepository handles:
                // - Copying image from temp URI to internal storage (logged out)
                // - Uploading image from temp URI to Firebase Storage (logged in)
                // - Setting the final imageName
                // - Saving PositionItem to SharedPreferences or Firestore
                // - De-duplication by name (for logged-in) or ID (for local)
                positionsRepository.addOrUpdatePosition(newPositionItem, tempImageFileUri)

            } catch (e: Exception) {
                Log.e(TAG, "Failed to import position ${exportablePosition.name}", e)
            } finally {
                // Temp image file for this specific position is handled by addOrUpdatePosition or should be deleted if addOrUpdatePosition fails before copying.
                // The main tempImageDir is deleted at the end.
            }
        }
    }

    private fun getExtensionFromMimeType(mimeType: String): String {
        return when (mimeType.lowercase()) {
            "image/jpeg" -> "jpg"
            "image/png" -> "png"
            "image/gif" -> "gif"
            "image/webp" -> "webp"
            else -> "dat" // Default extension
        }
    }

    private suspend fun importFavoriteSceneIds(
        favoriteExportIds: List<String>,
        exportedCustomScenes: List<ExportableScene>, // Original list of custom scenes from the import file
        userId: String?
    ) {
        if (favoriteExportIds.isEmpty()) return
        Log.d(TAG, "Importing ${favoriteExportIds.size} favorite scene IDs...")

        val currentScenesInApp = scenesViewModel.getCurrentScenesForExport()

        for (favExportId in favoriteExportIds) {
            var actualSceneIdToFavorite: String? = null

            // Strategy 1: Direct match (if favExportId is a stable ID like Firestore's or default_X)
            val directMatchScene = currentScenesInApp.find { it.getPersistentExportId() == favExportId }
            if (directMatchScene != null) {
                actualSceneIdToFavorite = directMatchScene.getPersistentExportId() // Use its current persistent ID
            } else {
                // Strategy 2: If favExportId was a local_ ID or for a custom scene,
                // find its original details from the export file, then match by content in current app scenes.
                val originalExportedScene = exportedCustomScenes.find { it.exportId == favExportId }
                if (originalExportedScene != null) {
                    val contentMatchScene = currentScenesInApp.find {
                        it.isCustom && // Ensure we are matching against a custom scene
                        it.title == originalExportedScene.title &&
                        it.content == originalExportedScene.content
                    }
                    if (contentMatchScene != null) {
                        actualSceneIdToFavorite = contentMatchScene.getPersistentExportId()
                    } else {
                        Log.w(TAG, "Could not find a matching scene in app for favorite with original exportId '$favExportId' (Title: ${originalExportedScene.title}) by content.")
                    }
                } else {
                     Log.w(TAG, "Favorite scene exportId '$favExportId' not found in the exported custom scenes list. It might be a default/asset scene or an orphaned ID.")
                     // If it's a default scene ID (e.g., "default_123"), it should have been caught by directMatchScene if the default scene exists.
                     // If it's an orphaned ID, we can't do much.
                }
            }

            if (actualSceneIdToFavorite != null) {
                if (userId == null) { // Logged out
                    localFavoritesRepository.addLocalFavoriteScene(actualSceneIdToFavorite)
                    Log.d(TAG, "Marked local scene '$actualSceneIdToFavorite' as favorite.")
                } else { // Logged in
                    val result = cloudFavoritesRepository.addFavorite(actualSceneIdToFavorite, "scene")
                    if (result.isSuccess) {
                        Log.d(TAG, "Successfully marked cloud scene '$actualSceneIdToFavorite' as favorite for user $userId.")
                    } else {
                        Log.e(TAG, "Failed to mark cloud scene '$actualSceneIdToFavorite' as favorite for user $userId.", result.exceptionOrNull())
                    }
                }
            } else {
                Log.w(TAG, "Could not resolve favorite scene with exportId '$favExportId' to an existing scene in the app.")
            }
        }
    }

    private suspend fun importFavoriteAssetPositionIds(assetPositionExportIds: List<String>, userId: String?) {
        if (assetPositionExportIds.isEmpty()) return
        Log.d(TAG, "Importing ${assetPositionExportIds.size} favorite asset position IDs...")
        for (exportId in assetPositionExportIds) { // These are like "asset_ImageName.jpg"
            if (userId == null) { // Logged out
                localFavoritesRepository.addLocalFavoritePosition(exportId)
            } else { // Logged in
                // Mark asset as favorite for user in Firestore.
                val result = cloudFavoritesRepository.addFavorite(exportId, "position")
                if (result.isSuccess) {
                    Log.d(TAG, "Successfully marked cloud asset position '$exportId' as favorite for user $userId.")
                } else {
                    Log.e(TAG, "Failed to mark cloud asset position '$exportId' as favorite for user $userId.", result.exceptionOrNull())
                }
                // Note: positionsRepository.updateFavoriteStatus(exportId, true) might also be needed if
                // the PositionItem itself (if one exists for assets for users) needs its 'isFavorite' flag updated in Firestore.
                // For now, relying on the 'favorites' collection via FavoritesRepository.
            }
        }
    }
}
